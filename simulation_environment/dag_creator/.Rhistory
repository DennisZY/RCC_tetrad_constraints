round(opprediction)
table(round(opprediction), optrectest[,65])
round(opprediction)
optrectest[,65]
table(round(opprediction), optrectest[,65])
help(table)
opprediction <- round(opprediction)
opprediction > 1
opprediction < 0
TRUE %in% opprediction < 0
table(round(opprediction), optrectest[,65])
TRUE %in% optrectest[,65] < 0
table(round(opprediction), optrectest[,65])
TRUE %in% optrectest[,65] < 0
TRUE %in% opprediction[,65] < 0
TRUE %in% opprediction < 0
TRUE %in% optrectest[,65] < 0
TRUE %in% opprediction < 0
table(opprediction, optrectest[,65])
TRUE %in% optrectest[,65] > 0
TRUE %in% optrectest[,65] > 9
TRUE %in% opprediction > 9
TRUE %in% opprediction > 9
TRUE %in% (opprediction > 9)
TRUE %in% (opprediction < 0)
TRUE %in% (opprediction < 1)
TRUE %in% (optrectest[,65] < 0)
TRUE %in% (optrectest[,65] > 9)
TRUE %in% (opprediction < 1)
(opprediction < 0) <- 0
opprediction[opprediction < 0] <- 0
TRUE %in% (opprediction < 0)
TRUE %in% (opprediction > 9)
TRUE %in% (opprediction > 9)
opprediction[opprediction > 9] <- 9
TRUE %in% (opprediction > 9)
table(opprediction, optrectest[,65])
summary(oppredictin)
summary(line)
table(opprediction, optrectest[,65])
optrec.step <- stepAIC(line ,scope=list(lower = ~1,upper = ~.^2),k=log(546))
library(ggplot2)
library(sm)
library(nnet)
library(caret)
mnist.data <- read.csv(paste(getwd(), "/mnist.csv", sep=""),header=TRUE)
summary(mnist.data[40])
summary(mnist.data[40])
mnist.data <- read.csv("/Users/jessebalster/Documents/Master AI/Pattern Recognition/Prac 2/Assignment 1/mnist.csv" ,header=TRUE)
check_only_zero <- function(data){
zerolist <- c()
for (i in (1: ncol(data))){
zerolist[i] <- (TRUE %in% (data[i] > 0))
}
return(zerolist)
}
summary(rowSums(mnist.data[-1]))
rowSums(mnist.data[-1])
summary(rowSums(mnist.data[-1]))
summary(colSums(mnist.data[-1]))
summary(colSums(mnist.data[-1]) / 42000)
summary(mnist.data[-1])
summary(mnist.data[5])
summary(mnist.data[20])
summary(mnist.data[50])
# Majority class
barplot(table(mnist.data[1]),space=0.5,ylim=c(0, 5000), main = 'Label counts in dataset',
xlab = 'Labels', ylab = 'Count', col = c("grey", "red", "grey", "grey", "grey", "grey", "grey", "grey", "grey"))
table(as.array(c(rep(1,42000))), mnist.data[,1])
# Convert to as.factor
mnist.data[,1] <- as.factor(mnist.data[,1])
### Calculate density ###
# Ink cost per class
ncol(mnist.data)
mnist.data.density <- mnist.data
mnist.data.density[786] <- rowSums(mnist.data[-1])
# Ink cost mean and SD
tapply(mnist.data.density$V786,mnist.data.density[,1],mean)
tapply(mnist.data.density$V786,mnist.data.density[,1],sd)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],dens)
plot(x$`3`)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],dens)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],density)
plot(x$`3`)
# Try to plot multiple density's
# Change options so that numbers are not in exponential notation.
options(scipen=5)
plot(x$`3`)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],density)
###
mnist.data.density <- mnist.data
mnist.data.density[786] <- rowSums(mnist.data[-1])
mnist.data.density$V786 <- scale(mnist.data.density$V786)
mnist.data.density$V786 <- mnist.data.density$V786 #+ 2.429067
summary(mnist.data.density$V786)
mlreg <- multinom(label ~ V786, mnist.data.density)
mpreg.pred <- predict(mlreg, mnist.data.density[,-1], type="class")
mytable <- table(mnist.data.density[,1], mpreg.pred)
mytable <- round(prop.table(mytable, 2) * 100, digits =2)
mytable <- 0
mytable[,9]
mnist.data.density$V786
count_only_zero <- function(data){
zerolist <- c()
for (i in (1: nrow(data))){
zerolist[i] <- (sum(data[i,] > 0))
}
return(zerolist)
}
counts_zero <- count_only_zero(mnist.data[-1])
sm.density.compare(mnist.data.density$V786, mnist.data.density$label, xlab="Average pixel cost of number")
title(main="Distributions of Species")
colfill<-c(2:(2+length(levels(mnist.data.density$label))))
legend(locator(1), levels(mnist.data.density$label), fill=colfill)
library(class)
library(caret)
library(devtools)
library(ggbiplot)
library(glmnet)
library(sm)
library(nnet)
library(e1071)
mnist.data <- read.csv("/Users/jessebalster/Documents/Master AI/Pattern Recognition/Prac 2/Assignment 1/mnist.csv" ,header=TRUE)
mnist.data[,1] <- factor(mnist.data[,1])
# Remove all features that are only 0
mnist.data.preproc <- mnist.data[, colSums(mnist.data != 0)> 0]
# Remove KNN features
mnist.data.preproc <- mnist.data.preproc[, colSums(mnist.data.preproc != 0) > 100]
zeroVars <- nearZeroVar(mnist.data[,-1], saveMetrics = T, freqCut = 500/1, uniqueCut = 1)
sum(zeroVars$nzv)
mnist.data.preproc <- mnist.data[,setdiff(names(mnist.data), rownames(zeroVars[zeroVars$nzv==TRUE,]))]
# TRAINING & TEST SET
traintestseed <- sample.int(nrow(mnist.data), 10000)
mnist.data.train <- mnist.data.preproc[traintestseed,]
mnist.data.test <- mnist.data.preproc[-traintestseed,]
optdigits.svm <- svm(mnist.data.train[,-1],mnist.data.train[,1], cost=5, gamma=0.002)
svm.pred <- predict(optdigits.svm,mnist.data.test[,-1])
confusionMatrix(as.factor(svm.pred), mnist.data.test[,1])
mnist.data[,1]
mnist.data[,1] > 0
mnist.data[,1]
mnist.data[,2]
mnist.data[,2] > 0
sum(mnist.data[,2] > 0)
sum(mnist.data[,500] > 0)
count_zero <- function(data){
zerolist <- c()
for (i in (1: ncol(data))){
zerolist[i] <- (sum(data[,i] > 0))
}
return(zerolist)
}
zeros <- count_zero(mnist.data)
zeros <- count_zero(mnist.data[,-1])
zeros
summary(zeros) <- count_zero(mnist.data[,-1])
summary(zeros)
summary(zeros / 42000) <- count_zero(mnist.data[,-1])
summary(zeros / 42000)
summary(zeros / 42000) * 100
library(mixtools)
install.packages("~/Documents/Master AI/Scriptie/Causal inference/Code/randomized_causation_coefficient-master/mixtools_1.2.0.tgz", repos = NULL, type = .Platform$pkgType)
setwd("/Users/jessebalster/Documents/Master-AI/Scriptie/Causal-inference/Code/simulation_environment/dag_creator")
gen_values = read.csv("generated_data.nosync/gen_values.csv")
cn = dim(gen_values)[2] / 4
row_num = 1430
plotys <- function(row_num) {
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
par(mfrow = c(2,2))
plot(density(df[,1]), main = "X1")
plot(density(df[,2]), main = "X2")
plot(density(df[,3]), main = "X3")
plot(density(df[,4]), main = "X4")
}
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
FactorModel<-'
Y1 =~ x1 + x2 + x3 + x4
'
FactorModel<-'
Y1 =~ x1 + x2
Y2 =~ x3 + x4
Y1 ~~ Y2
'
TetradTest(600)
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel)
}
TetradTest(600)
##################################################################################
#################################### Tetrad Function #################################
##################################################################################
TetradAnalysisNoRandom<-function(Samplecov,FactorModel,Size){
### "sweep_all" function is necessary to find Nonredundant vanishing tetrads from empirical vanishing tetrads ###
sweep<-function(A,k) {
B<-matrix(0,nrow=nrow(A),ncol=ncol(A))
if (abs(A[k,k])<2.2*10^(-10)){
B=A
for (i in 1:nrow(B)){
B[i,k]=0
B[k,i]=0
}
}
else if (A[k,k] !=0) {
for (i in 1:nrow(A)) {
for (j in 1: ncol(A)) {
if (i== k & j==k){
B[i,j]=1/A[k,k]
}
else if (i == k & j != k) {
B[i,j] = A[k,j]/A[k,k]
}
else if (i != k & j == k) {
B[i,j] = -A[i,k]/A[k,k]
}
else if (i != k & j != k) {
B[i,j] = A[i,j] - ( A[i,k]*A[k,j] / A[k,k])
}
}
}
}
return(B)
}
sweep_all<-function(A) {
B<-matrix(0,nrow=nrow(A),ncol=ncol(A))
for (i in 1: nrow(A)) {
B=sweep(A,i)
A=B
}
return(B)
}
##################################################################################
### Tetrad Function Part 1: Use Empirical Method to find model implied tetrad #####################
##################################################################################
### Information needed for Part 1 ###
### 1. Sample covariance matrix "Samplecov". ###
### 2. SEM model need to be tested "FactorModel". ###
### 3. Sample size "Size". ###
### Use function "ExampleTetrad" to get all model implied vanishing tetrads using empirical method. ###
EmpiricalMethod<-function(FactorModel,Samplecov){
### Package "lavaan" is used to get model implied covariance matrix "Modelcov", the synatax used to sepecify model is the same as syntax in "lavaan". ###
library(lavaan)
# I assume that you can also fit cfa with a dataset.
# CFA = confirmatory factor analysis.
FactorOut<-cfa(FactorModel, sample.cov=Samplecov, sample.nobs =Size)
# lavTech extracts: "cor.ov": The model-implied correlation matrix of the observed variables.
Modelcov<-data.frame(lavTech(FactorOut, "cov.ov"))*Size/(Size-1)
### List all tetrads in matrix "Tetrad", when there are N observed variables in inputted model. ###
N<-ncol(Modelcov)
x<-combn(1:N,4)
TetradNum<-choose(N, 4)
# Transpose
x1<-t(x)
x2<-cbind(x[1,],x[4,],x[2,],x[3,])
x3<-cbind(x[1,],x[3,],x[4,],x[2,])
y<-rbind(x1,x2,x3)
rownames(y)<-rep(1:TetradNum,3)
Y<-y[order(as.numeric(rownames(y))),]
Tetrad<-Y[,1]*1000+Y[,2]*100+Y[,3]*10+Y[,4]
### Calculate all tetrad values based on model implied covariance matrix "Modelcov". ###
### Save all tetrad values in a vector named "T", if the absolute tetrad value is less than 0.001, we assume it is a vanishing tetrad. ###
T<-matrix(1,nc=1,nr=nrow(Y))
for(i in 1:nrow(Y)){
T[i,1]<-round(Modelcov[Y[i,2],Y[i,1]]*Modelcov[Y[i,4],Y[i,3]]
-Modelcov[Y[i,3],Y[i,1]]*Modelcov[Y[i,4],Y[i,2]],2)
}
colnames(T) <- c("ImpliedValue")
implied<-matrix(,nrow=nrow(T))
colnames(implied) <- c("Implied")
for(i in 1:nrow(T)){
if(abs(T[i,1])>0.001) {implied[i,1]<-0} else{implied[i,1]<-1}
}
Tvalue<-matrix(1,nc=4,nr=nrow(Y))
for (i in 1:nrow(Y)){
Tvalue[i,1]<-min(Y[i,1],Y[i,2])*10+max(Y[i,1],Y[i,2])
Tvalue[i,2]<-min(Y[i,3],Y[i,4])*10+max(Y[i,3],Y[i,4])
Tvalue[i,3]<-min(Y[i,1],Y[i,3])*10+max(Y[i,1],Y[i,3])
Tvalue[i,4]<-min(Y[i,2],Y[i,4])*10+max(Y[i,2],Y[i,4])
}
colnames(Tvalue) <- c("1","2","3","4")
EmpiricalMethod_list<-list(EmpiricalMethod=cbind(Tetrad,Tvalue,implied,T), Modelcov=Modelcov)
return(EmpiricalMethod_list)
}
##################################################################################
########## Tetrad Function Part 2: Find Nonredundant vanishing tetrads ########################
##################################################################################
### Information needed for Part 2 ###
### 1. Model implied vanishing tetrads "ModelTetrad". ###
ExampleTetrad<-EmpiricalMethod(FactorModel,Samplecov)				# Use "EmpiricalMethod" function. #
ModelTetrad<-ExampleTetrad$EmpiricalMethod[ExampleTetrad$EmpiricalMethod[,6]==1,]	# Implied=1 means tetrad vanished in model. #
EmpiricalTetrads<-ModelTetrad[,1,drop=FALSE]					# Model implied tetrad names. #
### 2. All covariances in the model. ###
COV<-ModelTetrad[,2:5,drop=FALSE]
### 3. Model implied covariance matrix "Modelcov". ###
Modelcov<-ExampleTetrad$Modelcov
##################################################################################
### Use function "NRVT_Fun" to identify model implied nonredundant vanishing tetrads. ###
NRVT_Fun<-function(COV,ModelTetrad,Modelcov) {
if (nrow(COV)==1){			# If there is only one model implied vanishing tetrad, identify is unnecessary. #
NRVT<-ModelTetrad[1,1]
NRVT_Num<-1
}
else if (nrow(COV)>1) {		# If there is more than one model implied vanishing tetrad, identify is necessary. #
uc<-unique(as.vector(COV))	# Find all unique covariances among vanishing tetrads. #
SigmaSS<-matrix(1,nc=length(uc),nr=length(uc))
for (i in 1:length(uc)){
for (j in 1:length(uc)) {
e<-uc[i]%/%10
f<-uc[i]%%10
g<-uc[j]%/%10
h<-uc[j]%%10
efgh<-Modelcov[e,g]*Modelcov[f,h]+Modelcov[e,h]*Modelcov[f,g]
SigmaSS[i,j]<-efgh
}
}
### Get model implied SigmaTT based on model implied covariance matrix "Modelcov". ###
dtaudsigmaCOV<-matrix(0,ncol=length(uc),nrow=nrow(COV))
for (i in 1:nrow(dtaudsigmaCOV)){
for(j in 1:ncol(dtaudsigmaCOV)){
if (COV[i,1]==uc[j]) {dtaudsigmaCOV[i,j]=Modelcov[COV[i,2]%/%10,COV[i,2]%%10]}
if (COV[i,2]==uc[j]) {dtaudsigmaCOV[i,j]=Modelcov[COV[i,1]%/%10,COV[i,1]%%10]}
if (COV[i,3]==uc[j]) {dtaudsigmaCOV[i,j]=-Modelcov[COV[i,4]%/%10,COV[i,4]%%10]}
if (COV[i,4]==uc[j]) {dtaudsigmaCOV[i,j]=-Modelcov[COV[i,3]%/%10,COV[i,3]%%10]}
}
}
### use sweep operator to identify set of nonredundant vanishing tetrads. ###
SigmaTT<-dtaudsigmaCOV %*% SigmaSS %*% t(dtaudsigmaCOV)
SweepResults<-sweep_all(SigmaTT)
rowsum<-rowSums(SweepResults)
nrvt <- matrix(0, ncol=1, nrow=nrow(COV))
NRVT_Num<-0
for (i in 1: nrow(COV)) {
if ( rowsum[i] != 0 ) {			# If rowsum==0, that tetrad is redundant.#
nrvt[i,] = ModelTetrad[i,1]
NRVT_Num<-NRVT_Num+1
}
}
NRVT<-nrvt[nrvt[,1]!=0,]
}
NRVT_list<-list(NRVT=NRVT, NRVT_Num=NRVT_Num, uc=uc,Modelcov=Modelcov)
return(NRVT_list)
}
# This is almost a copy of the code below.
NRVT_Results<-NRVT_Fun(COV,ModelTetrad,Modelcov)
NRVT_Num<-NRVT_Results$NRVT_Num
NRVT<-NRVT_Results$NRVT
UniqueCov<-NRVT_Results$uc
##################################################################################
########## Tetrad Function Part 3: Individual Test and Multivariate Test  #########################
##################################################################################
### Information needed for Part 3 ###
### 1. Model implied nonredundant vanishing tetrads "NRVT". ###
NRVT_Results<-NRVT_Fun(COV,ModelTetrad,Modelcov)	# Use "NRVT_Fun" function. #
NRVT<-NRVT_Results$NRVT
### 2. Model implied nonredundant vanishing tetrad number "NRVT_Num" ###
NRVT_Num<-NRVT_Results$NRVT_Num
### 3. All unique covariances in vanishing tetrads "uc". ###
uc<-NRVT_Results$uc
##################################################################################
######### Individual test for every nonredundant tetrad #####################################
Tetrad<-matrix(1,nc=1,nr=NRVT_Num)
AVAR<-matrix(1,nc=1,nr=NRVT_Num)
Teststat<-matrix(1,nc=1,nr=NRVT_Num)
Pvalue<-matrix(1,nc=1,nr=NRVT_Num)
Fun<-t(t(NRVT))				# Get all nonredundant tetrads. #
NRVT_COV<-matrix(0, nrow=NRVT_Num,ncol=4)
for (k in 1:NRVT_Num){
e<-Fun[k,1]%/%1000
f<-Fun[k,1]%/%100%%10
g<-Fun[k,1]%/%10%%10
h<-Fun[k,1]%%10
sigma<-c(min(e,f)*10+max(e,f),min(g,h)*10+max(g,h),min(e,g)*10+max(e,g),min(f,h)*10+max(f,h))
NRVT_COV[k,1]<-sigma[1]
NRVT_COV[k,2]<-sigma[2]
NRVT_COV[k,3]<-sigma[3]
NRVT_COV[k,4]<-sigma[4]
SigmaSS<-matrix(1,nc=length(sigma),nr=length(sigma))	# Get SigmaSS based on Sample covariance matrix "Samplecov". #
for (i in 1:length(sigma)){
for (j in 1:length(sigma)) {
ee<-sigma[i]%/%10
ff<-sigma[i]%%10
gg<-sigma[j]%/%10
hh<-sigma[j]%%10
# Equation 17 in CTA paper, this assumes that the variables are multinormally distributed.
efgh<-Samplecov[ee,gg]*Samplecov[ff,hh]+Samplecov[ee,hh]*Samplecov[ff,gg]
SigmaSS[i,j]<-efgh
}
}
dt<-matrix(c(Samplecov[g,h],Samplecov[e,f],-Samplecov[f,h],-Samplecov[e,g]),ncol=4,nrow=1)
VAR<-(1/Size)* dt %*% SigmaSS %*% t(dt)
T<-Samplecov[e,f]*Samplecov[g,h]-Samplecov[e,g]*Samplecov[f,h]		# Calculate T values for individual tests. #
stat<-T^2/VAR
Chipvalue<-1-pchisq(stat,df=1)						# Calculate P-values for individual tests. #
Tetrad[k,1]<-round(T,3)
AVAR[k,1]<-round(VAR,3)
Teststat[k,1]<-round(stat,3)
Pvalue[k,1]<-round(Chipvalue,3)
}
Result<-cbind(Fun,Tetrad,AVAR,Teststat,Pvalue)
colnames(Result) <- c("Model Implied Tetrad","t","AVAR","TestStatistic","P-value")	# All results for individual tests. #
######### Multivariate test for overall model fit #################################################
### Get SigmaSS based on sample covariance matrix "Samplecov". ###
SigmaSS<-matrix(1,nc=length(uc),nr=length(uc))
for (i in 1:length(uc)){
for (j in 1:length(uc)) {
e<-uc[i]%/%10
f<-uc[i]%%10
g<-uc[j]%/%10
h<-uc[j]%%10
# Equation 17 in CTA paper, this assumes that the variables are multinormally distributed.
efgh<-Samplecov[e,g]*Samplecov[f,h]+Samplecov[e,h]*Samplecov[f,g]
SigmaSS[i,j]<-efgh
}
}
### Get SigmaTT, use dtau/dsigma and based on sample covariance matrix "Samplecov". ###
# See eq 19 in CTA paper.
dtaudsigmaCOV<-matrix(0,ncol=length(uc),nrow=NRVT_Num)
for (i in 1:nrow(dtaudsigmaCOV)){
for(j in 1:ncol(dtaudsigmaCOV)){
if (NRVT_COV[i,1]==uc[j]) {dtaudsigmaCOV[i,j]=Samplecov[NRVT_COV[i,2]%/%10,NRVT_COV[i,2]%%10]}
if (NRVT_COV[i,2]==uc[j]) {dtaudsigmaCOV[i,j]=Samplecov[NRVT_COV[i,1]%/%10,NRVT_COV[i,1]%%10]}
if (NRVT_COV[i,3]==uc[j]) {dtaudsigmaCOV[i,j]=-Samplecov[NRVT_COV[i,4]%/%10,NRVT_COV[i,4]%%10]}
if (NRVT_COV[i,4]==uc[j]) {dtaudsigmaCOV[i,j]=-Samplecov[NRVT_COV[i,3]%/%10,NRVT_COV[i,3]%%10]}
}
}
SigmaTT<-dtaudsigmaCOV %*% SigmaSS %*% t(dtaudsigmaCOV)
t<-t(t(Result[,2]))				# Get T values for all individual tests, use function "Result". #
T<-Size*t(t) %*% solve(SigmaTT) %*% t		# T value for multivariate test. #
MultiPvalue<-1-pchisq(T,df=NRVT_Num)		# P-value for multivariate test. #
colnames(T) <- c("TestStatistic For Multivariate Test")
colnames(MultiPvalue) <- c("P-value For Multivariate Test")
##################################################################################
########## Tetrad Function Part 4: Output all analysis results #################################
##################################################################################
results<-list(T=T, MultiPvalue=MultiPvalue,NRVT=NRVT,NRVT_Num=NRVT_Num,
EmpiricalTetrads=EmpiricalTetrads,Modelcov=Modelcov)
return(results)
}
TetradTest(600)
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel, row_num)
}
TetradTest(600)
## Use "TetradAnalysisNoRandom" to run Confirmatory Tetrad Analysis
Find1B<-TetradAnalysisNoRandom(Sampledata,FactorModel,Size)
Find1B
summary(cfa(FactorModel, sample.cov=cov(df), sample.nobs =1000))
TetradTest(600)
FactorModel<-'
Y1 =~ x1 + x2 + x3 + x4
'
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel, row_num)
}
TetradTest(600)
FactorModel<-'
Y1 =~ x1 + x2
Y2 =~ x3 + x4
Y1 ~~ Y2
'
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel, row_num)
}
TetradTest(600)
TetradTest(500)
TetradTest(100)
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel)
}
TetradTest(100)
TetradAnalysisNoRandom(cov(df), FactorModel, 100)
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel, 100)
}
TetradTest(100)
FactorModel<-'
Y1 =~ x1 + x2 + x3 + x4
'
TetradTest(100)
TetradTest(1000)
TetradTest(10)
TetradAnalysisNoRandom(cov(df), FactorModel, 1000)
TetradTest <- function(row_num){
plotys(row_num)
df <- data.frame(t(gen_values[row_num,1:cn]), t(gen_values[row_num,(cn+1):(cn*2)]), t(gen_values[row_num,(cn*2+1):(cn*3)]), t(gen_values[row_num,(cn*3+1):(cn*4)]))
colnames(df) = c("x1", "x2", "x3", "x4")
TetradAnalysisNoRandom(cov(df), FactorModel, 1000)
}
TetradTest(10)
