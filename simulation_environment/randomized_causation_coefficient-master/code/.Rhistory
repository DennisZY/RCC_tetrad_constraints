trainy$post[trainy$post > 1] <- 1
testy$post[testy$post > 1] <- 1
trainy
testy
confusionMatrix((factor(classyeclipse)),(factor(testy[,1])))
hprice.dat <- read.table("U:/PR/Datasets/hprice.txt",header=TRUE)
getwd()
hprice.dat <- read.table(getwd() + "/Documents/Master AI/Pattern Recognition/Prac 1/hprice.txt",header=TRUE)
getwd() + "/test"
getwd() + "/test"
getwd()
hprice.dat <- read.table(paste(getwd(), "/Documents/Master AI/Pattern Recognition/Prac 1/hprice.txt"),header=TRUE)
hprice.dat <- read.table(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/hprice.txt"),header=TRUE)
hprice.dat <- read.table(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/hprice.txt", sep=""),header=TRUE)
hprice.dat
dim(hprice.dat)
summary(hprice.dat)
help(lm)
hprice.lm1 <- lm(sale.price ~ lot.size + desire.loc,data=hprice.dat)
hprice.lm1
summary(hprice.lm1)
dim(hprice.dat)
hprice.lm1 <- lm(sale.price ~ .,data=hprice.dat)
summary(hprice.lm1)
library(MASS)
hprice.step <- stepAIC(hprice.lm2,scope=list(lower = ~1,upper = ~.^2),k=log(546))
hprice.lm2 <- lm(sale.price ~ .,data=hprice.dat)
hprice.step <- stepAIC(hprice.lm2,scope=list(lower = ~1,upper = ~.^2),k=log(546))
hprice.step
hprice.step$anova
summary(hprice.step)
x <- seq(0, 1, len=10)
x
x <- seq(0, 1, len=10)
set.seed(12345)
y <- sin(2*pi*x)+rnorm(n=10,mean=0,sd=0.3)
plot(x,y,ylim=c(-2,2))
x.graph <- seq(0,1,by=0.001)
y.graph <- sin(2*pi*x.graph)
lines(x.graph,y.graph,lwd=2,col=4)
help(graph)
lin <- lm(y~x,data.frame(y=y,x=x))
summary(lin)
lm(formula = y ~ x, data = data.frame(y = y, x = x))
y.lin.graph <- predict(lin,data.frame(x=x.graph))
lines(x.graph,y.lin.graph,lwd=2,col=1)
poly.3 <- lm(y~x+I(x^2)+I(x^3),data.frame(y=y,x=x))
summary(poly.3)
y.poly.3.graph <- predict(poly.3,data.frame(x=x.graph))
lines(x.graph,y.poly.3.graph,lwd=2,col=2)
poly.9 <- lm(y~x+I(x^2)+I(x^3)+I(x^4)+I(x^5)+I(x^6)+I(x^7)+I(x^8)+I(x^9),data.frame(y=y,x=x))
summary(poly.9)
y.poly.9.graph <- predict(poly.9,data.frame(x=x.graph))
lines(x.graph,y.poly.9.graph,lwd=2,col=6)
set.seed(54321)
y.testset <- sin(2*pi*x.graph)+rnorm(n=1001,mean=0,sd=0.3)
y.testset <- sin(2*pi*x.graph)+rnorm(n=1001,mean=0,sd=0.3)
error.lin <- sum((y.lin.graph-y.testset)^2)
error.lin
error.poly.3 <- sum((y.poly.3.graph-y.testset)^2)
error.poly.3
### PRAC 1
optrectrain <- read.table(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-train.txt", sep=""),header=TRUE)
optrectrain
optrectrain[1,]
optrectrain[2,]
optrectrain[2]
optrectrain[3]
optrectrain[,1]
optrectrain[1,]
optrectrain[100,]
len(optrectrain[100,])
length(optrectrain[100,])
(optrectrain[100,][,2])
(optrectrain[100,][,1])
(optrectrain[100,][2])
(optrectrain[100,][1])
(optrectrain[[100,]][1])
(optrectrain[100,][[1]])
(optrectrain[200,][[1]])
(optrectrain[500,][[1]])
(optrectrain[500,][[1]])
len(optrectrain[500,][[1]])
length(optrectrain[500,][[1]])
length(optrectrain[500,][[1]][[1]])
(optrectrain[500,][[1]][[1]])
### PRAC 1
optrectrain <- read.csv(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-train.txt", sep=""),header=TRUE)
(optrectrain[500,][[1]][[1]])
(optrectrain[500,][[1]])
(optrectrain[500,])
(optrectrain[1,])
(optrectrain[1,1])
(optrectrain)
### PRAC 1
optrectrain <- read.csv(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-train.txt", sep=","),header=FALSE)
### PRAC 1
optrectrain <- read.csv(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-train.txt", sep=","),header=FALSE)
### PRAC 1
optrectrain <- read.csv(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-train.txt", sep=""),header=FALSE)
(optrectrain)
(optrectrain[[1]])
(optrectrain[[2]])
(optrectrain[[3]])
(optrectrain[[,1]])
(optrectrain[,1)
(optrectrain[,1[])
(optrectrain[,1])
(optrectrain[1,])
optrectest <- read.csv(paste(getwd(),"/Documents/Master AI/Pattern Recognition/Prac 1/optdigits-test.txt", sep=""),header=FALSE)
optrectest[1,]
(optrectrain[optrectrain[> 0]])
(optrectrain[optrectrain[1] > 0])
(optrectrain[optrectrain[2] > 0])
(optrectrain[optrectrain[1] > 0])
(optrectrain[optrectrain[3] > 0])
(optrectrain[optrectrain[4] > 0])
(optrectrain[optrectrain[5] > 0])
(optrectrain[optrectrain[6] > 0])
(optrectrain[optrectrain[7] > 0])
[optrectrain[7] > 0]
optrectrain[7] > 0
optrectrain[1] > 0
TRUE %in% optrectrain[1] > 0
TRUE %in% optrectrain[2] > 0
check_only_zero <- function(data){
for i in ncol(data){
TRUE %in% optrectrain[i] > 0
}
}
check_only_zero <- function(data){
zerolist <- c()
for (i in ncol(data)){
zerolist[i] <- TRUE %in% optrectrain[i] > 0
}
return(zerolist)
}
check_only_zero(optrectrain)
check_only_zero <- function(data){
zerolist <- c()
for (i in ncol(data)){
zerolist[i] <- (TRUE %in% (optrectrain[i] > 0))
}
return(zerolist)
}
check_only_zero(optrectrain)
ncol(optrectrain)
check_only_zero <- function(data){
zerolist <- c()
for (i in [1: ncol(data)]){
zerolist[i] <- (TRUE %in% (optrectrain[i] > 0))
}
return(zerolist)
}
[1:10]
1:10
check_only_zero <- function(data){
zerolist <- c()
for (i in (1: ncol(data))){
zerolist[i] <- (TRUE %in% (optrectrain[i] > 0))
}
return(zerolist)
}
check_only_zero(optrectrain)
check_only_zero(optrectest)
check_only_zero(optrectrain)
colnames(optrectrain)
line <- lm(V65 ~ ., optrectrain)
line
hprice.lm2
line <- lm(V65 ~ ., data=optrectrain)
line
hprice.dat
colnames(optrectrain)
optrectrain
line <- lm(V65 ~ ., data=optrectrain)
summary(line)
help(predict.lm)
predict.lm(line, optrecettest)
predict.lm(line, optrecetest)
predict.lm(line, optrectest)
optrecttest[65]
optrectest[65]
predict.lm(line, optrectest)
optrectest[65]
opprediction <- predict.lm(line, optrectest)
table(opprediction, optrectest[65])
length(opprediction)
length(optrectest[65])
optrectest[65]
optrectest[65][1]
length(optrectest[65][1])
length(optrectest[65,[])
length(optrectest[65,])
(optrectest[65,]
optrectest[65,]
optrectest[65,]
optrectest[,65]
length(optrectest[,65])
length(opprediction)
table(opprediction, optrectest[,65])
opprediction
round(opprediction)
table(round(opprediction), optrectest[,65])
round(opprediction)
optrectest[,65]
table(round(opprediction), optrectest[,65])
help(table)
opprediction <- round(opprediction)
opprediction > 1
opprediction < 0
TRUE %in% opprediction < 0
table(round(opprediction), optrectest[,65])
TRUE %in% optrectest[,65] < 0
table(round(opprediction), optrectest[,65])
TRUE %in% optrectest[,65] < 0
TRUE %in% opprediction[,65] < 0
TRUE %in% opprediction < 0
TRUE %in% optrectest[,65] < 0
TRUE %in% opprediction < 0
table(opprediction, optrectest[,65])
TRUE %in% optrectest[,65] > 0
TRUE %in% optrectest[,65] > 9
TRUE %in% opprediction > 9
TRUE %in% opprediction > 9
TRUE %in% (opprediction > 9)
TRUE %in% (opprediction < 0)
TRUE %in% (opprediction < 1)
TRUE %in% (optrectest[,65] < 0)
TRUE %in% (optrectest[,65] > 9)
TRUE %in% (opprediction < 1)
(opprediction < 0) <- 0
opprediction[opprediction < 0] <- 0
TRUE %in% (opprediction < 0)
TRUE %in% (opprediction > 9)
TRUE %in% (opprediction > 9)
opprediction[opprediction > 9] <- 9
TRUE %in% (opprediction > 9)
table(opprediction, optrectest[,65])
summary(oppredictin)
summary(line)
table(opprediction, optrectest[,65])
optrec.step <- stepAIC(line ,scope=list(lower = ~1,upper = ~.^2),k=log(546))
library(ggplot2)
library(sm)
library(nnet)
library(caret)
mnist.data <- read.csv(paste(getwd(), "/mnist.csv", sep=""),header=TRUE)
summary(mnist.data[40])
summary(mnist.data[40])
mnist.data <- read.csv("/Users/jessebalster/Documents/Master AI/Pattern Recognition/Prac 2/Assignment 1/mnist.csv" ,header=TRUE)
check_only_zero <- function(data){
zerolist <- c()
for (i in (1: ncol(data))){
zerolist[i] <- (TRUE %in% (data[i] > 0))
}
return(zerolist)
}
summary(rowSums(mnist.data[-1]))
rowSums(mnist.data[-1])
summary(rowSums(mnist.data[-1]))
summary(colSums(mnist.data[-1]))
summary(colSums(mnist.data[-1]) / 42000)
summary(mnist.data[-1])
summary(mnist.data[5])
summary(mnist.data[20])
summary(mnist.data[50])
# Majority class
barplot(table(mnist.data[1]),space=0.5,ylim=c(0, 5000), main = 'Label counts in dataset',
xlab = 'Labels', ylab = 'Count', col = c("grey", "red", "grey", "grey", "grey", "grey", "grey", "grey", "grey"))
table(as.array(c(rep(1,42000))), mnist.data[,1])
# Convert to as.factor
mnist.data[,1] <- as.factor(mnist.data[,1])
### Calculate density ###
# Ink cost per class
ncol(mnist.data)
mnist.data.density <- mnist.data
mnist.data.density[786] <- rowSums(mnist.data[-1])
# Ink cost mean and SD
tapply(mnist.data.density$V786,mnist.data.density[,1],mean)
tapply(mnist.data.density$V786,mnist.data.density[,1],sd)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],dens)
plot(x$`3`)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],dens)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],density)
plot(x$`3`)
# Try to plot multiple density's
# Change options so that numbers are not in exponential notation.
options(scipen=5)
plot(x$`3`)
# plot density
x <- tapply(mnist.data.density$V786,mnist.data.density[,1],density)
###
mnist.data.density <- mnist.data
mnist.data.density[786] <- rowSums(mnist.data[-1])
mnist.data.density$V786 <- scale(mnist.data.density$V786)
mnist.data.density$V786 <- mnist.data.density$V786 #+ 2.429067
summary(mnist.data.density$V786)
mlreg <- multinom(label ~ V786, mnist.data.density)
mpreg.pred <- predict(mlreg, mnist.data.density[,-1], type="class")
mytable <- table(mnist.data.density[,1], mpreg.pred)
mytable <- round(prop.table(mytable, 2) * 100, digits =2)
mytable <- 0
mytable[,9]
mnist.data.density$V786
count_only_zero <- function(data){
zerolist <- c()
for (i in (1: nrow(data))){
zerolist[i] <- (sum(data[i,] > 0))
}
return(zerolist)
}
counts_zero <- count_only_zero(mnist.data[-1])
sm.density.compare(mnist.data.density$V786, mnist.data.density$label, xlab="Average pixel cost of number")
title(main="Distributions of Species")
colfill<-c(2:(2+length(levels(mnist.data.density$label))))
legend(locator(1), levels(mnist.data.density$label), fill=colfill)
library(class)
library(caret)
library(devtools)
library(ggbiplot)
library(glmnet)
library(sm)
library(nnet)
library(e1071)
mnist.data <- read.csv("/Users/jessebalster/Documents/Master AI/Pattern Recognition/Prac 2/Assignment 1/mnist.csv" ,header=TRUE)
mnist.data[,1] <- factor(mnist.data[,1])
# Remove all features that are only 0
mnist.data.preproc <- mnist.data[, colSums(mnist.data != 0)> 0]
# Remove KNN features
mnist.data.preproc <- mnist.data.preproc[, colSums(mnist.data.preproc != 0) > 100]
zeroVars <- nearZeroVar(mnist.data[,-1], saveMetrics = T, freqCut = 500/1, uniqueCut = 1)
sum(zeroVars$nzv)
mnist.data.preproc <- mnist.data[,setdiff(names(mnist.data), rownames(zeroVars[zeroVars$nzv==TRUE,]))]
# TRAINING & TEST SET
traintestseed <- sample.int(nrow(mnist.data), 10000)
mnist.data.train <- mnist.data.preproc[traintestseed,]
mnist.data.test <- mnist.data.preproc[-traintestseed,]
optdigits.svm <- svm(mnist.data.train[,-1],mnist.data.train[,1], cost=5, gamma=0.002)
svm.pred <- predict(optdigits.svm,mnist.data.test[,-1])
confusionMatrix(as.factor(svm.pred), mnist.data.test[,1])
mnist.data[,1]
mnist.data[,1] > 0
mnist.data[,1]
mnist.data[,2]
mnist.data[,2] > 0
sum(mnist.data[,2] > 0)
sum(mnist.data[,500] > 0)
count_zero <- function(data){
zerolist <- c()
for (i in (1: ncol(data))){
zerolist[i] <- (sum(data[,i] > 0))
}
return(zerolist)
}
zeros <- count_zero(mnist.data)
zeros <- count_zero(mnist.data[,-1])
zeros
summary(zeros) <- count_zero(mnist.data[,-1])
summary(zeros)
summary(zeros / 42000) <- count_zero(mnist.data[,-1])
summary(zeros / 42000)
summary(zeros / 42000) * 100
library(mixtools)
install.packages("~/Documents/Master AI/Scriptie/Causal inference/Code/randomized_causation_coefficient-master/mixtools_1.2.0.tgz", repos = NULL, type = .Platform$pkgType)
install.packages("mixtools")
library(mixtools)
write('SampleID,A,B',file='syn_pairs.csv')
write_pair <- function(x,y) {
write(paste(i, paste(x,collapse=" "), paste(y,collapse=" "), sep=","),
append=TRUE, file="syn_pairs.csv")
}
cause <- function(n,k=5,p1=5,p2=5) {
w <- abs(runif(k))
w <- w/sum(w)
m <- rnorm(k,0,p1)
s <- abs(rnorm(k,1,p2))
scale(rnormmix(n,w,m,s))
}
noise <- function(n,v) {
v*rnorm(n)
}
mechanism <- function(x,d=10) {
g <- seq(min(x)-sd(x),max(x)+sd(x),length.out=d)
function(z) predict(smooth.spline(g,rnorm(d)),z)$y
}
N  <- 5000
set.seed(0)
for(i in 1:N) {
x <- cause(1000)
f <- mechanism(x)
e <- noise(length(x),runif(1))
write_pair(x,scale(f(x))+e)
}
write.table(cbind(1:(1*N),1,0),sep=",", quote=FALSE,
col.names=F,row.names=F,file="syn_target.csv")
N
N
f
e
f
x
1*N
N
1:N
1:(1*N)
cbind(1:(1*N),1,0)
library(mixtools)
write('SampleID,A,B',file='syn_pairs.csv')
write_pair <- function(x,y) {
write(paste(i, paste(x,collapse=" "), paste(y,collapse=" "), sep=","),
append=TRUE, file="syn_pairs.csv")
}
cause <- function(n,k=5,p1=5,p2=5) {
w <- abs(runif(k))
w <- w/sum(w)
m <- rnorm(k,0,p1)
s <- abs(rnorm(k,1,p2))
scale(rnormmix(n,w,m,s))
}
noise <- function(n,v) {
v*rnorm(n)
}
mechanism <- function(x,d=10) {
g <- seq(min(x)-sd(x),max(x)+sd(x),length.out=d)
function(z) predict(smooth.spline(g,rnorm(d)),z)$y
}
N  <- 5000
set.seed(0)
for(i in 1:N) {
x <- cause(1000)
f <- mechanism(x)
e <- noise(length(x),runif(1))
write_pair(x,scale(f(x))+e)
}
write.table(cbind(1:(1*N),1,0),sep=",", quote=FALSE,
col.names=F,row.names=F,file="syn_target.csv")
getwd()
setwd("/Users/jessebalster/Documents/Master AI/Scriptie/Causal inference/Code/randomized_causation_coefficient-master/code")
getwd()
library(mixtools)
write('SampleID,A,B',file='syn_pairs.csv')
write_pair <- function(x,y) {
write(paste(i, paste(x,collapse=" "), paste(y,collapse=" "), sep=","),
append=TRUE, file="syn_pairs.csv")
}
cause <- function(n,k=5,p1=5,p2=5) {
w <- abs(runif(k))
w <- w/sum(w)
m <- rnorm(k,0,p1)
s <- abs(rnorm(k,1,p2))
scale(rnormmix(n,w,m,s))
}
noise <- function(n,v) {
v*rnorm(n)
}
mechanism <- function(x,d=10) {
g <- seq(min(x)-sd(x),max(x)+sd(x),length.out=d)
function(z) predict(smooth.spline(g,rnorm(d)),z)$y
}
N  <- 5000
set.seed(0)
for(i in 1:N) {
x <- cause(1000)
f <- mechanism(x)
e <- noise(length(x),runif(1))
write_pair(x,scale(f(x))+e)
}
write.table(cbind(1:(1*N),1,0),sep=",", quote=FALSE,
col.names=F,row.names=F,file="syn_target.csv")
N
cbind(1:(1*N),1,0)
len(cbind(1:(1*N),1,0))
length(cbind(1:(1*N),1,0))
cause(1000)
noise(1000,runif(1))
for(i in 1:N) {
x <- cause(1000)
f <- mechanism(x)
e <- noise(length(x),runif(1))
write_pair(x,scale(f(x))+e)
}
N  <- 5000
set.seed(0)
x <- cause(1000)
cause <- function(n,k=5,p1=5,p2=5) {
w <- abs(runif(k))
w <- w/sum(w)
m <- rnorm(k,0,p1)
s <- abs(rnorm(k,1,p2))
scale(rnormmix(n,w,m,s))
}
noise <- function(n,v) {
v*rnorm(n)
}
mechanism <- function(x,d=10) {
g <- seq(min(x)-sd(x),max(x)+sd(x),length.out=d)
function(z) predict(smooth.spline(g,rnorm(d)),z)$y
}
x <- cause(1000)
library(mixtools)
x <- cause(1000)
f <- mechanism(x)
e <- noise(length(x),runif(1))
paste(x,collapse=" ")
len(paste(x,collapse=" "))
dim(paste(x,collapse=" "))
paste(x,collapse=" ")
xnew = paste(x,collapse=" ")
